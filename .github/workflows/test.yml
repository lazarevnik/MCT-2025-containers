name: Docker Compose Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  SQLX_OFFLINE: true

jobs:
  test-compose:
    runs-on: ubuntu-latest

    env:
      DB_USER: docker
      DB_PASSWORD: docker
      DB_NAME: pingvisits

    defaults:
      run:
        working-directory: ./ping-visits

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Start services
        run: docker compose up -d

      - name: Wait for web to be ready
        run: |
          timeout=60
          while ! curl -f http://localhost:8080 >/dev/null 2>&1; do
            ((timeout--))
            if [ $timeout -eq 0 ]; then
              echo "Web service failed to start"
              exit 1
            fi
            sleep 1
          done

      - name: Test web response
        run: |
          response=$(curl -s http://localhost:8080/ping)
          if [[ "$response" != "pong" ]]; then
            echo "Expected 'pong', got: $response"
            exit 1
          fi
          echo "Web test passed!"

      - name: Test PostgreSQL connection
        run: |
          docker compose exec -T db pg_isready -U "${DB_USER}" -d "${DB_NAME}"

      - name: Test database initialized
        run: |
          echo "Checking whether table 'visits' with columns 'ip_address', 'id' and 'created_at' exists"
          cols=$(docker compose exec -T db psql -U "${DB_USER}" -d "${DB_NAME}" -tAc "SELECT column_name FROM information_schema.columns WHERE table_name='visits' ORDER BY ordinal_position;")
          if [[ "$cols" != *"id"* || "$cols" != *"ip_address"* || "$cols" != *"created_at"* ]]; then
            echo "Table 'visits' missing expected columns."
            exit 1
          fi
          echo "Table 'visits' with columns 'id', 'ip_address' and 'created_at' exists!"

      - name: Test Redis caching behavior
        run: |
          first=$(curl -s http://localhost:8080/visits)
          cached=$(docker compose exec -T redis redis-cli GET nvisits || true)
          if [[ -z "$cached" ]]; then
            echo "Cache not populated after first /visits"
            exit 1
          fi
          echo "Redis cache populated"

          second=$(curl -s http://localhost:8080/visits)
          if [[ "$first" != "$second" ]]; then
            echo "Cache miss: expected $first, got $second"
            exit 1
          fi
          echo "Cache hit is correct"

          curl -s http://localhost:8080/ping > /dev/null
          sleep 1

          after_ping=$(docker compose exec -T redis redis-cli GET nvisits || true)
          if [[ -n "$after_ping" ]]; then
            echo "Cache should be invalidated, but found: $after_ping"
            exit 1
          fi
          echo "Redis cache invalidated after /ping"

      - name: Show logs on failure
        if: failure()
        run: docker compose logs

  test-compose-dev:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./ping-visits

    steps:
      - uses: actions/checkout@v4

      - name: Start application
        run: docker compose -f docker-compose.dev.yml up -d

      - name: Test /visits in dev mode response
        run: |
          response=$(curl -s http://localhost:8080/visits)
          if [[ "$response" != "-1" ]]; then
            echo "Dev mode test failed: expected -1, got $response"
            exit 1
          fi
          echo "Dev mode test passed"

      - name: Test /ping response
        run: |
          response=$(curl -s http://localhost:8080/ping)
          if [[ "$response" != "pong" ]]; then
            echo "Expected 'pong', got: $response"
            exit 1
          fi
          echo "Web test passed!"

      - name: Show logs on failure
        if: failure()
        run: docker compose logs

  test-coverage:
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: ./ping-visits

    services:
      db:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: docker
          POSTGRES_PASSWORD: docker
          POSTGRES_DB: pingvisits
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U ${DB_USER} -d ${DB_NAME}"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:8-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgres://docker:docker@localhost:5432/pingvisits
      REDIS_URL: redis://localhost:6379
      RUST_BACKTRACE: 1

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Install cargo-tarpaulin
        run: cargo install cargo-tarpaulin

      - name: Wait for database
        run: |
          echo "Waiting for Postgres..."
          for i in {1..15}; do
            if pg_isready -h localhost -U ${POSTGRES_USER} -d ${POSTGRES_DB}; then
              echo "Postgres is ready"
              break
            fi
            echo "Waiting..."
            sleep 2
          done

      - name: Run migrations
        run: |
          sudo apt-get update && sudo apt-get install -y postgresql-client
          psql $DATABASE_URL -c "create table if not exists visits (id serial primary key, ip_address text not null, created_at timestamp default now());"

      - name: Run coverage check
        run: cargo tarpaulin --timeout 120 --fail-under 60 --out Html

      - name: Upload coverage report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: /home/runner/work/MCT-2025-containers/MCT-2025-containers/ping-visits/tarpaulin-report.html
